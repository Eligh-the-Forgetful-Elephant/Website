#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/extensions/shape.h>
#include <X11/Xatom.h>
#include <unistd.h>
#include <cmath>
#include <vector>
#include <cstring>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <signal.h>
#include <stdlib.h>
#include <iostream>

// Obfuscated configuration
#define W_W 800
#define W_H 600
#define G_W 64
#define G_H 64
#define M_S 5

// Goose state with obfuscated names
struct G_State {
    int pos_x, pos_y;
    int targ_x, targ_y;
    bool moving;
    int dir;
};

// Function to create goose shape
std::vector<XPoint> create_shape(int x, int y, int d) {
    std::vector<XPoint> p;
    if (d == 0) {
        p.push_back({static_cast<short>(x), static_cast<short>(y)});
        p.push_back({static_cast<short>(x + G_W), static_cast<short>(y + G_H/2)});
        p.push_back({static_cast<short>(x), static_cast<short>(y + G_H)});
    } else {
        p.push_back({static_cast<short>(x + G_W), static_cast<short>(y)});
        p.push_back({static_cast<short>(x), static_cast<short>(y + G_H/2)});
        p.push_back({static_cast<short>(x + G_W), static_cast<short>(y + G_H)});
    }
    return p;
}

// Update position
void update_pos(G_State& g) {
    if (!g.moving) return;

    int dx = g.targ_x - g.pos_x;
    int dy = g.targ_y - g.pos_y;
    float dist = std::sqrt(dx * dx + dy * dy);

    if (dist < M_S) {
        g.pos_x = g.targ_x;
        g.pos_y = g.targ_y;
        g.moving = false;
    } else {
        g.pos_x += (dx / dist) * M_S;
        g.pos_y += (dy / dist) * M_S;
    }

    g.dir = (dx > 0) ? 0 : 1;
}

// Signal handler to prevent termination
void sig_handler(int sig) {
    // Ignore termination signals
    if (sig == SIGTERM || sig == SIGINT) {
        return;
    }
}

int main() {
    // Set up signal handlers
    signal(SIGTERM, sig_handler);
    signal(SIGINT, sig_handler);
    
    // Fork to background
    if (fork() != 0) {
        return 0;
    }

    // Open display
    Display* d = XOpenDisplay(NULL);
    if (!d) {
        std::cerr << "Failed to open display" << std::endl;
        return 1;
    }

    int s = DefaultScreen(d);
    Window r = RootWindow(d, s);

    // Create window with minimal properties
    Window w = XCreateSimpleWindow(d, r, 0, 0, W_W, W_H, 0,
                                 BlackPixel(d, s), WhitePixel(d, s));

    // Set window properties for visibility
    XSetWindowAttributes a;
    a.override_redirect = True;
    a.background_pixel = WhitePixel(d, s);
    a.border_pixel = BlackPixel(d, s);
    XChangeWindowAttributes(d, w, CWOverrideRedirect | CWBackPixel | CWBorderPixel, &a);

    // Set window title
    XStoreName(d, w, "Desktop Goose");

    // Make window stay on top
    Atom wm_state = XInternAtom(d, "_NET_WM_STATE", False);
    Atom wm_state_above = XInternAtom(d, "_NET_WM_STATE_ABOVE", False);
    XChangeProperty(d, w, wm_state, XA_ATOM, 32, PropModeReplace,
                   (unsigned char*)&wm_state_above, 1);

    // Make click-through
    XShapeCombineRectangles(d, w, ShapeInput, 0, 0, NULL, 0, ShapeSet, YXBanded);

    // Map and raise window
    XMapWindow(d, w);
    XRaiseWindow(d, w);
    XFlush(d);

    // Initialize goose
    G_State g = {
        W_W / 2,
        W_H / 2,
        W_W / 2,
        W_H / 2,
        false,
        0
    };

    // Create graphics context
    GC gc = XCreateGC(d, w, 0, NULL);
    XSetForeground(d, gc, BlackPixel(d, s));

    // Main loop
    while (true) {
        while (XPending(d)) {
            XEvent e;
            XNextEvent(d, &e);

            if (e.type == ButtonPress) {
                g.targ_x = e.xbutton.x;
                g.targ_y = e.xbutton.y;
                g.moving = true;
            }
        }

        update_pos(g);

        XClearWindow(d, w);
        std::vector<XPoint> p = create_shape(g.pos_x, g.pos_y, g.dir);
        XFillPolygon(d, w, gc, p.data(), p.size(), Convex, CoordModeOrigin);

        XFlush(d);
        usleep(10000);
    }

    // Cleanup (unreachable due to while(true))
    XFreeGC(d, gc);
    XDestroyWindow(d, w);
    XCloseDisplay(d);

    return 0;
}

